##地址	http://html54stock.outofmemory.cn/
#set( $layout = "layout/null.vm" )
<script src="#resources('/kline/loading.js')" type="text/javascript"></script>
<script src="#resources('/kline/util.js')" type="text/javascript"></script>
<script src="#resources('/kline/absPainter.js')" type="text/javascript"></script>
<script src="#resources('/kline/ajax.js')" type="text/javascript"></script>
<script src="#resources('/kline/crossLines.js')" type="text/javascript"></script>
<script src="#resources('/kline/axis-x.js')" type="text/javascript"></script>
<script src="#resources('/kline/tip.js')" type="text/javascript"></script>
<script src="#resources('/kline/linepainter.js')" type="text/javascript"></script>
<script src="#resources('/kline/volumePainter.js')" type="text/javascript"></script>
<script src="#resources('/kline/axis-y.js')" type="text/javascript"></script>
<script src="#resources('/kline/chartEventHelper.js')" type="text/javascript"></script>
<script type="text/javascript">
    function convertDate(val, withWeek) {
		var dateArr = val.split("-");
        var year = dateArr[0];
        var day = dateArr[2];
        var month = dateArr[1];
        var d = new Date();
        d.setYear(year);
        d.setMonth(month - 1);
        d.setDate(day);
        if (withWeek) {
            var weekNames = ['日', '一', '二', '三', '四', '五', '六'];
            return year + '-' + month + '-' + day + '(星期' + weekNames[d.getDay()] + ')';
        } else {
            return year + '-' + month + '-' + day;
        }
    }
    function calcMAPrices(ks, startIndex, count, daysCn) {
        var result = new Array();
        for (var i = startIndex; i < startIndex + count; i++) {
            var startCalcIndex = i - daysCn + 1;
            if (startCalcIndex < 0) {
                result.push(false);
                continue;
            }
            var sum = 0;
            for (var k = startCalcIndex; k <= i; k++) {
                sum += ks[k].close;
            }
            var val = sum / daysCn;
            result.push(val);
        }
        return result;
    }

    function kLine(options) {
        this.options = options;
        this.dataRanges = null;
    }

    kLine.prototype = {
        initialize: function (painter) {
            painter.klOptions = this.options;
            painter.implement = this;
        },
        start: function () {
            var canvas = this.canvas;
            var ctx = this.ctx;
            this.painting = true;
            var options = this.klOptions;
            var clearPart = { width: canvas.width, height: options.priceLine.region.y - 3 };
            ctx.clearRect(0, 0, clearPart.width, clearPart.height);

            ctx.save();
            window.riseColor = options.riseColor;
            window.fallColor = options.fallColor;
            window.normalColor = options.normalColor;
            if (options.backgroundColor && !this.drawnBackground) {
                ctx.beginPath();
                ctx.fillStyle = options.backgroundColor;
                ctx.rect(0, 0, clearPart.width, clearPart.height);
                ctx.fill();
                //ctx.closePath();
                this.drawnBackground = true;
            }
            ctx.translate(options.region.x, options.region.y);
            ctx.strokeStyle = options.borderColor;
            ctx.beginPath();
            ctx.rect(0, 0, options.region.width, options.region.height);
            ctx.stroke();
            //画水平底纹线
            var spaceHeight = options.region.height / (options.horizontalLineCount + 1);
            for (var i = 1; i <= options.horizontalLineCount; i++) {
                var y = spaceHeight * i;
                if (y * 10 % 10 == 0) y += .5;
                this.drawHLine(options.splitLineColor, 0, y, options.region.width, 1, options.lineStyle);
            }
            //画垂直底纹线
            var spaceWidth = options.region.width / (options.verticalLineCount + 1);
            for (var i = 1; i <= options.verticalLineCount; i++) {
                var w = spaceWidth * i;
                if (w * 10 % 10 == 0) w += .5;
                this.drawVLine(options.splitLineColor, w, 0, options.region.height, 1, options.lineStyle);
            }
        },
        end: function () {
            this.ctx.restore();
            var me = this;
            var options = me.klOptions;
            var region = options.region;
            var volumeRegion = options.volume.region;

            function getIndex(x) {
                x -= region.x;
                var index = Math.ceil(x / (me.klOptions.spaceWidth + me.klOptions.barWidth)) - 1;
                var count = me.toIndex - me.startIndex + 1;
                if (index >= count) index = count - 1;
                return index;
            }
            function getX(x) {
                var index = getIndex(x);
                return region.x + me.klOptions.spaceWidth * (index + 1) + me.klOptions.barWidth * index + me.klOptions.barWidth * .5;
            }
            function getPriceColor(ki, price) {
                if (price > ki.preClose) {
                    return riseColor;
                } else if (price < ki.preClose) {
                    return fallColor;
                } else {
                    return normalColor;
                }
            }
            function getTipHtml(x) {
                var index = me.startIndex + getIndex(x);
                if (index >= me.data.ks.length) index = me.data.ks.length - 1;
                if (index < 0) index = 0;
                var ki = me.data.ks[index];
				var op = ((ki.open-ki.yc)*100/ki.yc).toFixed(2)+"%";
                var tipHtml = '<div><b>' + convertDate(ki.quoteTime) + '</b></div>' +
                '开盘价：<font color="' + getPriceColor(ki, ki.open) + '">' + toMoney(ki.open) + '(' +op+')</font><br/>' +
                '最高价：<font color="' + getPriceColor(ki, ki.high) + '">' + toMoney(ki.high) + '</font><br/>' +
                '最低价：<font color="' + getPriceColor(ki, ki.low) + '">' + toMoney(ki.low) + '</font><br/>' +
               '收盘价：<font color="' + getPriceColor(ki, ki.close) + '">' + toMoney(ki.close) + '</font><br/>' +
                '成交量：' + bigNumberToText(ki.volume / 100) + '手<br/>' +
				'换手率：' + ki.tt.toFixed(2)+"<br/>"+
				'涨跌：' + ki.percent+'%(' + ki.chgAmt+"元)<br/>";
                return tipHtml;
            }

            function getEventOffsetPosition(ev){                    
                var offset = isTouchDevice()
                    ? setTouchEventOffsetPosition(ev, getPageCoord(me.canvas))
                    : getOffset(ev);
                return offset;
            }
            
            var controllerEvents = {
                onStart:function(ev){
                    ev = ev || event;
                    var offset = getEventOffsetPosition(ev);
                    me.controllerStartOffset = offset;
                    me.controllerStartRange = me.dataRanges;
                },
                onEnd:function(ev){
                    me.controllerStartOffset = null;
                    me.controllerStartRange = null;
                },
                onMove:function(ev){
                    if(!me.controllerStartOffset) return;
                    ev = ev || event;
                    var offset = getEventOffsetPosition(ev);
                    var moveX = offset.offsetX - me.controllerStartOffset.offsetX;
                    var currentRange = me.controllerStartRange;/*0-100*/
                    var regionWidth = region.width;
                    var moveValue =0- (moveX/regionWidth)*(currentRange.to-currentRange.start);
                    var start = currentRange.start+moveValue;
                    var to = currentRange.to + moveValue;
                    if(start<0) {
                        start = 0;
                        to = start + (currentRange.to-currentRange.start);
                    }
                    else{
                        if(to > 100){
                            to = 100;
                            start = to-(currentRange.to-currentRange.start);
                        }
                    }                        
                    var changeToValue = {left:start,right:to};
                    if(!me.painting) drawKL({ start: changeToValue.left, to: changeToValue.right });
                }
            };

            /*
            当touchstart时的位置在K线柱附近时表示要显示柱的描述信息框；否则则要控制K线的范围
            */
            var fingerSize = {width:30,height:20};
            function shouldDoControllerEvent(ev,evtType){
                if(evtType == undefined) return true;
                if(typeof me.shouldController == 'undefined') me.shouldController = true;
                
                return me.shouldController;
            }

            if(!me.crossLineAndTipMgrInstance){
                me.crossLineAndTipMgrInstance = new crossLinesAndTipMgr(me.canvas, {
                    getCrossPoint: function (ev) { return { x: getX(ev.offsetX), y: ev.offsetY }; },
                    triggerEventRanges: { x: region.x, y: region.y + 1, width: region.width, height: volumeRegion.y + volumeRegion.height - region.y },
                    tipOptions: {
                        getTipHtml: function (ev) {
							return getTipHtml(ev.offsetX); 
						},
                        size:{width:150,height:160},
                        position:{x:false,y:region.y+(region.height-150)/3}, //position中的值是相对于canvas的左上角的
                        opacity:80,
                        cssClass:'',
                        offsetToPoint:30
                    },
                    crossLineOptions: {
                        color: 'black'
                    },
                    shouldDoControllerEvent:shouldDoControllerEvent,
                    controllerEvents:controllerEvents
                });
                me.crossLineAndTipMgrInstance.addCrossLinesAndTipEvents();
            }
            else {
                me.crossLineAndTipMgrInstance.updateOptions({
                        getCrossPoint: function (ev) { return { x: getX(ev.offsetX), y: ev.offsetY }; },
                        triggerEventRanges: { x: region.x, y: region.y + 1, width: region.width, height: volumeRegion.y + volumeRegion.height - region.y },
                        tipOptions: {
                            getTipHtml: function (ev) {
								alert(222);
								return getTipHtml(ev.offsetX); 
							},
                            size:{width:120,height:150},
                            position:{x:false,y:region.y+(region.height-150)/3}, //position中的值是相对于canvas的左上角的
                            opacity:80,
                            cssClass:'',
                            offsetToPoint:30
                        },
                        crossLineOptions: {
                            color: 'black'
                        },
                        shouldDoControllerEvent:shouldDoControllerEvent,
                        controllerEvents:controllerEvents
                    });
            }

            me.painting = false;
        },
        paintItems: function () {
            var options = this.klOptions;
            var region = options.region;
            var maxDataLength = this.data.ks.length;
            var needCalcSpaceAndBarWidth = true;
            if (this.dataRanges == null) {
                //计算dataRanges
                var dataCount = Math.ceil(region.width / (options.spaceWidth + options.barWidth))-1;
                if (dataCount > maxDataLength) dataCount = maxDataLength;

                this.dataRanges = {
                    start: 100 * (this.data.ks.length - dataCount) / this.data.ks.length,
                    to: 100
                };

                needCalcSpaceAndBarWidth = false;
            }
            var dataRanges = this.dataRanges;
            var startIndex = Math.ceil(dataRanges.start / 100 * maxDataLength);
            var toIndex = Math.ceil(dataRanges.to / 100 * maxDataLength) + 1;
            if (toIndex == maxDataLength) toIndex = maxDataLength - 1;
            this.startIndex = startIndex;
            this.toIndex = toIndex;
            var itemsCount = toIndex - startIndex + 1;
            if (needCalcSpaceAndBarWidth) {
                //重新计算spaceWidth和barWidth属性
                function isOptionsOK() { return (options.spaceWidth + options.barWidth) * itemsCount <= region.width; }
                var spaceWidth, barWidth;
                if (isOptionsOK()) {
                    //柱足够细了
                    spaceWidth = 1;
                    barWidth = (region.width - spaceWidth * itemsCount) / itemsCount;
                    if (barWidth > 4) {
                        spaceWidth = 2;
                        barWidth = ((region.width - spaceWidth * itemsCount) / itemsCount);
                    }
                } else {
                    spaceWidth = 1;
                    barWidth = (region.width - spaceWidth * itemsCount) / itemsCount;
                    if (barWidth <= 2) {
                        spaceWidth = 0;
                        barWidth = (region.width - spaceWidth * itemsCount) / itemsCount;
                    } else if (barWidth > 4) {
                        spaceWidth = 2;
                        barWidth = ((region.width - spaceWidth * itemsCount) / itemsCount);
                    }
                }

                options.barWidth = barWidth;
                options.spaceWidth = spaceWidth;
            }

            var filteredData = [];
            for (var i = startIndex; i <= toIndex && i < maxDataLength; i++) {
                filteredData.push(this.data.ks[i]);
            }
            var high, low;
            filteredData.each(function (val, a, i) {
                if (i == 0) { high = val.high; low = val.low; }
                else { high = Math.max(val.high, high); low = Math.min(low, val.low); }
            });

            this.high = high;
            this.low = low;
            var ctx = this.ctx;
            var me = this;
            //画移动平均线
            this.implement.paintMAs.call(this, filteredData, getY);
            function getY(price) { return (me.high - price) * region.height / (me.high - me.low); }
            function getCandleLineX(i) { var result = i * (options.spaceWidth + options.barWidth) + (options.spaceWidth + options.barWidth) * .5; if (result * 10 % 10 == 0) result += .5; return result; }

            var currentX = 0;
            var needCandleRect = options.barWidth > 1.5;
            var drawCandle = function (ki, a, i) {
                var isRise = ki.close > ki.open;
				var percent = ki.percent;
				var color = riseColor;
				if(ki.close < ki.open){
					color = fallColor;
				} else if(ki.close == ki.open) {
					if(percent < 0){
						color = fallColor;
					}
				}
                //var color = isRise ? riseColor : fallColor;

                var lineX = getCandleLineX(i);
                if (currentX == 0) currentX = lineX;
                else {
                    if (lineX - currentX < 1) return;
                }
                currentX = lineX;
                var topY = getY(ki.high);
                var bottomY = getY(ki.low);
                if (needCandleRect) {
                    ctx.fillStyle = color;
                    ctx.strokeStyle = color;
                    var candleY, candleHeight;
                    if (ki.close > ki.open) {
                        candleY = getY(ki.close);
                        candleHeight = getY(ki.open) - candleY;
                    } else if(ki.close < ki.open) {
                        candleY = getY(ki.open);
                        candleHeight = getY(ki.close) - candleY;
                    } else {
						candleY = getY(ki.close);
						candleHeight = 0.7;
					}
					if(candleHeight < 0.7){
						candleHeight = 0.9
					}
                    //画线
                    ctx.beginPath();
                    ctx.moveTo(lineX, topY);
                    ctx.lineTo(lineX, bottomY);
                    ctx.stroke();

                    var candleX = lineX - options.barWidth / 2;
                    ctx.beginPath();
                    ctx.fillRect(candleX, candleY, options.barWidth, candleHeight);
                } else {
                    ctx.strokeStyle = color;
                    //画线
                    ctx.beginPath();
                    ctx.moveTo(lineX, topY);
                    ctx.lineTo(lineX, bottomY);
                    ctx.stroke();
                }

            };
            //画蜡烛
            filteredData.each(drawCandle);
            this.filteredData = filteredData;

            var yAxisOptions = options.yAxis;
            yAxisOptions.region = yAxisOptions.region || { x: 0 - region.x, y: 0 - 3, height: region.height, width: region.x - 3 };
            //画y轴
            var yAxisImp = new yAxis(yAxisOptions);
            var yPainter = new Painter(
                this.canvas.id,
                yAxisImp,
                calcAxisValues(high, low, (options.horizontalLineCount + 2))
            );
            yPainter.paint();
			
            //画X轴
            var xAxisOptions = options.xAxis;
            xAxisOptions.region = { x: 0, y: region.height + 2, width: region.width, height: 20 };
            var xAxisImp = new xAxis(xAxisOptions);
            var xScalers = [];
            var stepLength = filteredData.length / (options.xAxis.scalerCount - 1);
            if (stepLength < 1) {
                options.xAxis.scalerCount = filteredData.length;
                stepLength = 1;
            }
            xScalers.push(convertDate(filteredData[0].quoteTime, false).substr(2));
            for (var i = 1; i < options.xAxis.scalerCount; i++) {
                var index = Math.ceil(i * stepLength);
                if (index >= filteredData.length) index = filteredData.length - 1;
                var quoteTime = convertDate(filteredData[index].quoteTime, false);
                quoteTime = quoteTime.substr(2);
                xScalers.push(quoteTime);
            }
            var xPainter = new Painter(this.canvas.id, xAxisImp, xScalers);
            xPainter.paint();

            //画量
            this.implement.paintVolume.call(this, filteredData);
  
            //画价格线                
            //this.implement.paintPriceLine.call(this);
        },
        paintPriceLine: function () {
            if (this.hasPaintPriceLine) return;
            this.hasPaintPriceLine = true;
            var ctx = this.ctx;
            var options = this.klOptions.priceLine;
            var region = options.region;
            ctx.save();
            ctx.translate(region.x, region.y);

            ctx.clearRect(0 - region.x, 0, this.canvas.width, region.height);
            //画水平底纹线
            var spaceHeight = region.height / (options.horizontalLineCount + 1);
            for (var i = 1; i <= options.horizontalLineCount; i++) {
                var y = spaceHeight * i;
                if (y * 10 % 10 == 0) y += .5;
                this.drawHLine(options.splitLineColor, 0, y, region.width, 1, options.lineStyle);
            }
            //画垂直底纹线
            var spaceWidth = region.width / (options.verticalLineCount + 1);
            for (var i = 1; i <= options.verticalLineCount; i++) {
                var w = spaceWidth * i;
                if (w * 10 % 10 == 0) w += .5;
                this.drawVLine(options.splitLineColor, w, 0, region.height, 1, options.lineStyle);
            }
            var ks = this.data.ks;

            var ksLength = ks.length;
            var priceRange;
            ks.each(function (val, arr, i) {
                if (i == 0) { priceRange = { high: val.high, low: val.low }; }
                else {
                    priceRange.high = Math.max(priceRange.high, val.close);
                    priceRange.low = Math.min(priceRange.low, val.close);
                }
            });
            if (priceRange.low > 1) priceRange.low -= 1;
            function getRangeX(i) { return i * region.width / ksLength; }
            function getRangeY(val) { return (priceRange.high - val) * region.height / (priceRange.high - priceRange.low); }
            var currentX = 0;
            ks.each(function (val, arr, i) {
                var x = getRangeX(i);
                if (currentX == 0) currentX = x;
                else {
                    if (x - currentX < 1) return;
                }
                currentX = x;
                var y = getRangeY(val.close);
                if (i == 0) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.strokeStype = options.borderColor;
            ctx.stroke();
            ctx.lineTo(region.width, region.height);
            ctx.lineTo(0, region.height);
            ctx.closePath();
            ctx.fillStyle = options.fillColor;
            ctx.globalAlpha = options.alpha;
            ctx.fill();
            ctx.globalAlpha = 1;
            var yAxisOptions = options.yAxis;
            yAxisOptions.region = yAxisOptions.region || { x: 0 - region.x, y: 0 - 3, height: region.height, width: region.x - 3 };
            //画y轴
            var yAxisImp = new yAxis(yAxisOptions);
            var yPainter = new Painter(
                this.canvas.id,
                yAxisImp,
                calcAxisValues(priceRange.high, priceRange.low, (options.horizontalLineCount + 2))
            );

            yPainter.paint();
            ctx.restore();
        },
        paintMAs: function (filteredData, funcGetY) {
            var ctx = this.ctx;
            var options = this.klOptions;
            var MAs = options.MAs;
            var me = this;
            MAs.each(function (val, arr, index) {
                var MA = calcMAPrices(me.data.ks, me.startIndex, filteredData.length, val.daysCount);
                val.values = MA;
                MA.each(function (val, arr, i) {
                    if (val) {
                        me.high = Math.max(me.high, val);
                        me.low = Math.min(me.low, val);
                    }
                });
            });

            MAs.each(function (val, arr, index) {
                var MA = val.values;
                ctx.strokeStyle = val.color;
                ctx.beginPath();
                var currentX = 0;
                MA.each(function (val, arr, i) {
                    var x = i * (options.spaceWidth + options.barWidth) + (options.spaceWidth + options.barWidth) * .5;
                    
                    if (!val) return;
                    var y = funcGetY(val);
                    if (y && i==0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
            });
        },
        paintVolume: function (filteredData) {
            var ctx = this.ctx;
            var options = this.klOptions;
            //画量线
            var volumeOptions = options.volume;
            var volumeRegion = volumeOptions.region;
            ctx.restore();
            ctx.save();
            ctx.translate(volumeRegion.x, volumeRegion.y);
            ctx.globalAlpha = 1;
            //画水平底纹线
            var spaceHeight = volumeRegion.height / (volumeOptions.horizontalLineCount + 1);
            for (var i = 1; i <= volumeOptions.horizontalLineCount; i++) {
                var y = spaceHeight * i;
                if (y * 10 % 10 == 0) y += .5;
                this.drawHLine(options.splitLineColor, 0, y, options.region.width, 1, options.lineStyle);
            }
            //画垂直底纹线
            var spaceWidth = options.region.width / (options.verticalLineCount + 1);
            for (var i = 1; i <= options.verticalLineCount; i++) {
                var w = spaceWidth * i;
                if (w * 10 % 10 == 0) w += .5;
                this.drawVLine(options.splitLineColor, w, 0, volumeRegion.height, 1, options.lineStyle);
            }

            ctx.strokeStyle = options.borderColor;
            ctx.beginPath();
            ctx.rect(0, 0, volumeRegion.width, volumeRegion.height);
            ctx.stroke();
            //drawLines(ctx, [{ direction: 'H', position: .50, color: 'lightgray'}]);
            var maxVolume = 0;

            filteredData.each(function (val, arr, i) {
                maxVolume = Math.max(maxVolume, val.volume);
            });
            maxVolume *= 1.05;
            function getVolumeY(v) { return volumeRegion.height - volumeRegion.height / maxVolume * v; }
            function getVolumeX(i) { return i * (options.spaceWidth + options.barWidth) + (options.spaceWidth) * .5; }
            ctx.globalAlpha = 1;
            filteredData.each(function (val, arr, i) {
                var x = getVolumeX(i);
                var y = getVolumeY(val.volume);
                ctx.beginPath();
                ctx.rect(x, y, options.barWidth, volumeRegion.height / maxVolume * val.volume);
				ctx.fillStyle = riseColor;
				if(val.close < val.open){
					ctx.fillStyle = fallColor;
				} else if(val.open == val.close){
					if(val.percent < 0){
						ctx.fillStyle = fallColor;
					}
				}
                ctx.fill();
            });

            //画y轴
            var volumeLevel;
            var volumeUnit;
            if (maxVolume < 10000 * 100) {
                volumeLevel = 10000;
                volumeUnit = '万';
            }
            else {
                volumeLevel = 10000 * 100;
                volumeUnit = '百万';
            }

            var volumeScalers = [];
            volumeScalers.push((maxVolume / volumeLevel).toFixed(2));
            volumeScalers.push((maxVolume / 2 / volumeLevel).toFixed(2));
            volumeScalers.push(volumeUnit);
            var volumeScalerOptions = volumeOptions.yAxis;
            volumeScalerOptions.region = volumeScalerOptions.region || { x: 0 - volumeRegion.x, y: -3, width: volumeRegion.x - 3, height: volumeRegion.height };
            var volumeScalerImp = new yAxis(volumeScalerOptions);
            var volumeScalerPainter = new Painter(this.canvas.id, volumeScalerImp, volumeScalers);
            volumeScalerPainter.paint();
            ctx.restore();
            ctx.save();
        },
        onOrentationChanged: function (e) {//针对设备横竖屏的处理
            var orientation = window.orientation;
            function getWidth() { return screen.width-40;/*((orientation == 90 || orientation == -90) ? screen.width : screen.height) - 40; */}
            if (typeof orientation != 'undefined') {
                setDebugMsg('orientation=' + orientation + ',getWidth=' + getWidth());
                //if(orientation == 90 || orientation == -90 || orientation == 0){
                var me = this;
                var width = getWidth();
                //var rate = width/me.canvas.width;
                me.canvas.width = width;
                var options = me.klOptions;
                var chartWidth = width - options.chartMargin.left - options.chartMargin.right;
                me.klOptions.volume.region.width =
                        me.klOptions.priceLine.region.width =
                        me.klOptions.region.width = chartWidth;
                //方向改变了，要重画controller
                me.controller = null;
                me.hasPaintPriceLine = false;
                drawKL({ start: me.dataRanges.start, to: me.dataRanges.to });
                // }
            }
        }
    };
    
    var painter;// = new Painter('canvasKL', kl, data);
    var initialWidth = Math.min(screen.width,1024)-40;
    function drawKL(ranges) {            
        var kOptions = {
            backgroundColor:'#fff',
            riseColor: 'red',
            fallColor: 'green',
            normalColor: 'black',
            //主图区域的边距
            chartMargin:{left:45.5,top:20.5,right:20.5},
            region: { x: 45.5, y: 20.5, width: initialWidth - 45.5 - 20.5, height: 250 },
            barWidth: 5, spaceWidth: 2, horizontalLineCount: 7, verticalLineCount: 7, lineStyle: 'solid', borderColor: 'gray', splitLineColor: '#eeeeee', lineWidth: 1,
            MAs: [
                { color: 'rgb(255,70,251)', daysCount: 5 },
                { color: 'rgb(227,150,34)', daysCount: 10 },
                { color: 'rgb(53,71,107)', daysCount: 20 }/*,
                { color: 'rgb(0,0,0)', daysCount: 60 }*/
                ],
            yAxis: {
                font: '11px Arial', // region: { },
                color: 'black',
                align: 'right',
                fontHeight: 8,
                textBaseline: 'top'
            },
            xAxis: {
                font: '11px Arial', // region: { },
                color: 'black',
                align: 'right',
                fontHeight: 8,
                textBaseline: 'top',
                scalerCount: 9
            },
            volume: {
                region: { x: 45.5, y: 290.5, height: 80, width: initialWidth - 45.5 - 20.5 },
                horizontalLineCount: 1,
                yAxis: {
                    font: '11px Arial', // region: { },
                    color: 'black',
                    align: 'right',
                    fontHeight: 8,
                    textBaseline: 'top'
                }
            },
            priceLine: {
                region:{ x: 45.5, y: 390.5, height: 60, width: initialWidth - 45.5 - 20.5 },
                verticalLineCount: 7,
                horizontalLineCount: 1, lineStyle: 'solid', borderColor: 'gray', splitLineColor: '#eeeeee',fillColor:'lightgray',alpha:.5,
                yAxis: {
                    font: '11px Arial', // region: { },
                    color: 'black',
                    align: 'right',
                    fontHeight: 8,
                    textBaseline: 'top'
                }
            }
        };
       
        if(!painter){            
            var canvas = $id('canvasKL');
            if(canvas.width != initialWidth) canvas.width = initialWidth;
            var kl = new kLine(kOptions);
            var data = getKLData();
            painter = new Painter('canvasKL', kl, data);
        }
        painter.dataRanges = ranges;
        painter.paint();
    }

</script>
<div>
    MA:<span style="color:rgb(255,70,251)">-----5</span>
    <span style="color:rgb(227,150,34)">-----10</span>
    <span style="color:rgb(53,71,107)">-----20</span>
    <span style="color:rgb(0,0,0)">-----60</span>
</div>
<canvas id="canvasKL" width="984" height="390" style="z-index: 2; border: 1px solid #69c">
    <p>hey,您的浏览器不支持html5，换个浏览器吧，比如google chrome，firefox</p>
</canvas>
<script type="text/javascript">
function getKLData() {
	var data = #SLITERAL($!{klData});
    var result = {};
    var ks = [];
    for (var i = 0; i < data.length; i++) {
        var rawData = data[i];
        //20111215,11.68,11.65,11.76,11.40,11.41,43356655,502325991
        //日期,昨收,开盘价,高,低，收,量，额
        var item = {
            quoteTime: rawData[0],
            open: rawData[1],
            high: rawData[2],
            low: rawData[3],
            close: rawData[4],
            volume: rawData[5],
			percent: rawData[6],
			chgAmt: rawData[7],
			yc:rawData[8],
			tt:rawData[9]
        };
        if (ks.length == 0) {
            result.low = item.low;
            result.high = item.high;
        } else {
            result.high = Math.max(result.high, item.high);
            result.low = Math.min(result.low, item.low);
        }
        ks.push(item);
    }
    result.ks = ks;
    return result;
}
drawKL();
</script>